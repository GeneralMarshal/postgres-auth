# Step 02: Roles Setup

**Goal**: Add roles to User model and update database schema

## Prerequisites

- ✅ Completed Step 01
- ✅ Understanding of authentication vs authorization
- ✅ Prisma schema knowledge

## What Are Roles?

**Roles** are labels that define what a user can do in your application. Common roles include:

- **`user`** - Regular user (default)
- **`admin`** - Administrator with full access
- **`moderator`** - Can moderate content
- **`manager`** - Can manage team resources

**Why Roles?**

- ✅ Simple to understand and implement
- ✅ Easy to check permissions
- ✅ Flexible for most applications
- ✅ Industry standard (RBAC)

## Step 1: Add UserRole Enum and Role Field

Open `prisma/schema.prisma` and add a `UserRole` enum plus a `role` field on the User model:

```prisma
enum UserRole {
  USER
  ADMIN
  MODERATOR
  MANAGER
}

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String
  name      String?
  role      UserRole @default(USER)  // ← Add this line
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
```

**Breaking it down:**

- `enum UserRole` - Defines allowed roles (USER, ADMIN, MODERATOR, MANAGER)
- `role UserRole` - Role stored as enum, not string
- `@default(USER)` - Default role is USER
- No `@unique` - Multiple users can have the same role

**Why use an enum:**

- ✅ Type safety in TypeScript (via generated Prisma client)
- ✅ Prevents typos (can't use "admn" instead of "ADMIN")
- ✅ IDE autocomplete
- ✅ Single source of truth; Prisma generates `UserRole` for you

## Step 2: Generate Prisma Client

After updating the schema, generate the Prisma client:

```bash
npx prisma generate
```

**What this does:**

- ✅ Updates TypeScript types
- ✅ `User` type now includes `role: UserRole` (enum)
- ✅ Prisma generates `UserRole` from `@prisma/client` for use in your code

## Step 3: Push Schema to Database

Apply the schema changes to your database:

```bash
npx prisma db push
```

**What this does:**

- ✅ Adds `role` column to `User` table (as enum type)
- ✅ Sets default value to USER for existing users
- ✅ Updates database schema

**Alternative (if using migrations):**

```bash
npx prisma migrate dev --name add_user_role
```

## Step 4: Verify Database Changes

Check that the column was added:

```bash
npx prisma studio
```

Or use `psql`:

```sql
\d "User"
```

You should see the `role` column with default value `USER` (enum).

## Step 5: Update User DTOs

Import `UserRole` from the Prisma client and use `@IsEnum(UserRole)` so only valid enum values are accepted.

Update `src/user/dto/create-user.dto.ts`:

```typescript
import {
  IsEmail,
  IsNotEmpty,
  IsString,
  MinLength,
  IsOptional,
  IsEnum,
} from 'class-validator';
import { UserRole } from '@prisma/client';

export class CreateUserDto {
  @IsNotEmpty({ message: 'Email is required' })
  @IsEmail({}, { message: 'Please provide a valid email address' })
  email: string;

  @IsNotEmpty({ message: 'Password is required' })
  @IsString()
  @MinLength(8, { message: 'Password must be at least 8 characters long' })
  password: string;

  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsEnum(UserRole, {
    message: 'Role must be one of: USER, ADMIN, MODERATOR, MANAGER',
  })
  role?: UserRole;
}
```

**Breaking it down:**

- `UserRole` from `@prisma/client` - Generated by Prisma from your schema
- `@IsOptional()` - Role is optional (defaults to USER in schema)
- `@IsEnum(UserRole)` - Only allows enum values (USER, ADMIN, MODERATOR, MANAGER)

**Update `src/user/dto/update-user.dto.ts`:**

```typescript
import {
  IsEmail,
  IsOptional,
  IsString,
  MinLength,
  IsBoolean,
  IsEnum,
} from 'class-validator';
import { UserRole } from '@prisma/client';

export class UpdateUserDto {
  @IsOptional()
  @IsEmail({}, { message: 'Please provide a valid email address' })
  email?: string;

  @IsOptional()
  @IsString()
  @MinLength(8, { message: 'Password must be at least 8 characters long' })
  password?: string;

  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsBoolean()
  isActive?: boolean;

  @IsOptional()
  @IsEnum(UserRole, {
    message: 'Role must be one of: USER, ADMIN, MODERATOR, MANAGER',
  })
  role?: UserRole;
}
```

## Step 6: Update User Service (Optional)

If you want to ensure role defaults to USER when creating users, update `src/user/users.service.ts` (add `import { UserRole } from '@prisma/client'` at the top):

```typescript
async create(createUserDto: CreateUserDto) {
  const existingUser = await this.findByEmail(createUserDto.email);

  if (existingUser) {
    throw new ConflictException('User with this email already exists');
  }

  const hashedPassword = await this.passwordService.hashPassword(
    createUserDto.password,
  );

  const user = await this.prisma.user.create({
    data: {
      email: createUserDto.email,
      password: hashedPassword,
      name: createUserDto.name,
      role: createUserDto.role ?? UserRole.USER,  // ← Default to USER (enum)
    },
  });

  const { password: _, ...userWithoutPassword } = user;
  return userWithoutPassword;
}
```

**Note:** Prisma will use the default value from the schema, but being explicit is clearer. Use `UserRole.USER` if you import from `@prisma/client`.

## Step 7: Update JWT Payload (Optional)

If you want to include role in the JWT token, update `src/auth/services/jwt/jwt.service.ts`:

```typescript
import { UserRole } from '@prisma/client';

export interface JwtPayload {
  sub: string; // User ID
  email: string;
  role?: UserRole; // ← Add role (enum)
  jti: string; // Token ID
  iat: number; // Issued at
  exp: number; // Expiration
}
```

**Update `generateToken` method:**

```typescript
async generateToken(
  userId: string,
  email: string,
  role?: UserRole,  // ← Add role parameter (enum)
): Promise<{ token: string; tokenId: string }> {
  const tokenId = this.getTokenId();
  const payload: JwtPayload = {
    sub: userId,
    email,
    role,  // ← Include role in payload
    jti: tokenId,
    iat: Math.floor(Date.now() / 1000),
    exp: Math.floor(Date.now() / 1000) + this.expiresIn,
  };

  const token = this.jwtService.sign(payload);
  return { token, tokenId };
}
```

**Update `UsersService.login` to pass role:**

```typescript
async login(loginUserDto: LoginUserDto) {
  const user = await this.findByEmail(loginUserDto.email);

  if (!user) {
    throw new UnauthorizedException('Invalid credentials');
  }

  const isPasswordValid = await this.passwordService.comparePassword(
    loginUserDto.password,
    user.password,
  );

  if (!isPasswordValid) {
    throw new UnauthorizedException('Invalid credentials');
  }

  const { token, tokenId } = await this.jwtService.generateToken(
    user.id,
    user.email,
    user.role,  // ← Pass role
  );

  await this.sessionService.createSession(tokenId, {
    userId: user.id,
    email: user.email,
    role: user.role,  // ← Include role in session
    createdAt: new Date().toISOString(),
  });

  const { password: _, ...userWithoutPassword } = user;
  return {
    user: userWithoutPassword,
    accessToken: token,
  };
}
```

**Benefits of including role in JWT:**

- ✅ No database lookup needed to check role
- ✅ Faster authorization checks
- ✅ Role available in token payload

**Trade-offs:**

- ❌ Role changes require re-login (or token refresh)
- ❌ Token size slightly larger

## Step 8: Create Role Constants (Optional)

Create `src/common/constants/roles.ts` to re-export `UserRole` and define metadata keys and role groups:

```typescript
export { UserRole } from '@prisma/client';

export const ROLES_KEY = 'roles';

/** Admin-only roles */
export const ADMIN_ROLES = [UserRole.ADMIN] as const;

/** Moderator and above */
export const MODERATOR_ROLES = [UserRole.ADMIN, UserRole.MODERATOR] as const;
```

**Usage:**

```typescript
import { UserRole, ADMIN_ROLES } from 'src/common/constants/roles';

if (user.role === UserRole.ADMIN) {
  // Admin logic
}

@Roles(...ADMIN_ROLES)  // Type-safe
```

## Step 9: Test the Changes

**1. Create a user with default role:**

```bash
POST /users/register
{
  "email": "user@example.com",
  "password": "password123",
  "name": "Regular User"
}
```

**Expected:** User created with `role: "USER"` (default enum value)

**2. Create an admin user:**

```bash
POST /users/register
{
  "email": "admin@example.com",
  "password": "password123",
  "name": "Admin User",
  "role": "ADMIN"
}
```

**Expected:** User created with `role: "ADMIN"`

**3. Update user role:**

```bash
PATCH /users/:id
Authorization: Bearer <token>
{
  "role": "MODERATOR"
}
```

**Expected:** User role updated to MODERATOR (valid enum values: USER, ADMIN, MODERATOR, MANAGER)

## Common Issues

**Issue 1: "Column 'role' does not exist"**

**Solution:** Run `npx prisma db push` to apply schema changes.

**Issue 2: "Invalid role value"**

**Solution:** Use enum values in the API: USER, ADMIN, MODERATOR, MANAGER (uppercase). DTOs use `@IsEnum(UserRole)`.

**Issue 3: "Type error: Property 'role' does not exist" or "UserRole is not defined"**

**Solution:** Run `npx prisma generate` so `UserRole` is available from `@prisma/client`.

## Summary

**What we did:**

1. ✅ Added `UserRole` enum and `role` field to User model
2. ✅ Set default role to USER
3. ✅ Updated Prisma schema and database
4. ✅ Updated DTOs with `@IsEnum(UserRole)`
5. ✅ (Optional) Included role in JWT payload as enum

**Current state:**

- ✅ Users have roles (enum)
- ✅ Roles stored in database as enum type
- ✅ DTOs validate with `UserRole` from `@prisma/client`
- ✅ Roles can be included in JWT tokens

**Next step:**
Now that users have roles, let's create guards that check these roles!

---

**Ready?** Move to [STEP-03-role-guards.md](./STEP-03-role-guards.md)!
